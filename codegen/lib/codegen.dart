import 'dart:async';

import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';

class NomoCode {
  const NomoCode();
}

/*



@NomoCode()
class Online {
  final Browser _browser;
  final Page _page;

  Online(this._browser, this._page);

  Future<Online> visit(String url) async {
    await _page.goto(url);
    return this;
  }

  Future<Online> type(String selector, String text) async {
    await _page.type(selector, text);
    return this;
  }

  Future<Online> click(String selector) async {
    await _page.click(selector);
    return this;
  }

  Future<Online> waitFor(String selector) async {
    await _page.waitForSelector(selector);
    return this;
  }

  Future<Online> has(String selector, String text) async {
    var element = await _page.$(selector);
    var elementText = await _page
        .evaluate('(element) => element.textContent', args: [element]);
    if (elementText != text) {
      throw Exception(
          'Expected $selector to have text $text, but found $elementText');
    }
    return this;
  }

  Future<Online> close() async {
    await _browser.close();
    return this;
  }
}

provided the code above, the generated code should look like this:

// extension ExOnline on Future<Online> {
//   Future<Online> visit(String url) async {
//     var online = await this;
//     return online.visit(url);
//   }

//   Future<Online> type(String selector, String text) async {
//     var online = await this;
//     return online.type(selector, text);
//   }

//   Future<Online> click(String selector) async {
//     var online = await this;
//     return online.click(selector);
//   }

//   Future<Online> waitFor(String selector) async {
//     var online = await this;
//     return online.waitFor(selector);
//   }

//   Future<Online> has(String selector, String text) async {
//     var online = await this;
//     return online.has(selector, text);
//   }

//   Future<Online> close() async {
//     var online = await this;
//     return online.close();
//   }
// }

*/

class FutureGenerator extends GeneratorForAnnotation<NomoCode> {
  @override
  FutureOr<String> generateForAnnotatedElement(
      Element element, ConstantReader annotation, BuildStep buildStep) {
    if (element is! ClassElement) {
      throw InvalidGenerationSourceError(
          'Generator cannot target `$element`. `@NomoCode()` can only be applied to classes.');
    }

    final classElement = element;
    final className = classElement.name;
    final buffer = StringBuffer();

    buffer.writeln('/// CODE GENERATED BY nomo_code GENERATOR. DO NOT EDIT.');
    buffer.writeln();
    //import original file
    buffer.writeln("/// IMPORTING ORIGINAL SOURCE");
    buffer.writeln("import '${buildStep.inputId.path.split('/').last}';");
    buffer.writeln();
    //extension
    buffer.writeln('/// GENERATED EXTENSION');
    buffer.writeln('extension Ex$className on Future<$className> {');

    for (var method in classElement.methods) {
      if (method.isOperator || method.isAbstract) {
        continue;
      }

      final methodName = method.name;
      final methodReturnType = method.returnType;
      final methodParameters = method.parameters;

      buffer.writeln();
      buffer.writeln('  Future<$className> $methodName(');

      for (var parameter in methodParameters) {
        final parameterName = parameter.name;
        final parameterType = parameter.type;

        buffer.writeln('    $parameterType $parameterName,');
      }

      buffer.writeln('  ) async {');
      buffer.writeln('    var $className = await this;');
      buffer.writeln('    return $className.$methodName(');

      for (var parameter in methodParameters) {
        final parameterName = parameter.name;

        buffer.writeln('      $parameterName,');
      }

      buffer.writeln('    );');

      buffer.writeln('  }');

      buffer.writeln();
    }

    buffer.writeln('  }');

    return buffer.toString();
  }
}
